 Which Sorting Algorithm Should I Use?
 (Depends. Each algorithm comes with its own set of pros and cons.)

---------

Selection Sort: This sorting algorithm sorts an array by repeatedly finding the minimum element
(considering ascending order) from the unsorted part and putting it at the beginning. The algorithm
maintains two subarrays in a given array, the subarray which is already sorted, and the remaining
subarray which is unsorted. In every iteration of the selection sort, the minimum element
(considering ascending order) from the unsorted subarray is picked and moved to the sorted subarray.

! ! ! use this when: When the list is small. As the time complexity of the selection sort is O(N^2)
                         which makes it inefficient for a large list.
                     When memory space is limited because it makes the minimum possible number of
                         swaps during sorting.

---------

Bubble sort: This sorting algorithm is the simplest sorting algorithm that works by repeatedly
swapping the adjacent elements if they are in the wrong order. If we have total N elements, then
we need to repeat the above process for N-1 times.

! ! ! use this when: It works well with large datasets where the items are almost sorted because
                        it takes only one iteration to detect whether the list is sorted or not.
                        But if the list is unsorted to a large extend then this algorithm holds
                        good for small datasets or lists.
                     This algorithm is fastest on an extremely small or nearly sorted set of data.

=========
Selection sort and bubble sort are good for small lists. bubble is better if the list is very small
    or nearly sorted. bubble is also good on large datasets where the items are almost sorted.
=========

Insertion Sort: This sorting algorithm is a simple sorting algorithm that works the way we sort
playing cards in our hands. It places an unsorted element at its suitable place in each iteration.

! ! ! use this when: If the data is nearly sorted or when the list is small as it has a complexity
                        of O(N^2) and if the list is sorted a minimum number of elements will slide
                        over to insert the element at its correct location.
                     This algorithm is stable and it has fast running case when the list is nearly
                        sorted.
                     The usage of memory is a constraint as it has space complexity of O(1).

---------

Merge sort: This sorting algorithm is based on the Divide and Conquer algorithm. It divides the
    input array into two halves, calls itself for the two halves, and then merges the two sorted
    halves. The merge() function is used for merging two halves.

! ! ! use  this when: Merge sort is used when the data structure doesn’t support random access
                        since it works with pure sequential access that is forward iterators,
                        rather than random access iterators.
                      It is widely used for external sorting, where random access can be very,
                        very expensive compared to sequential access.

---------

Quick sort: This sorting algorithm is also based on the Divide and Conquer algorithm. It picks an
            element as a pivot and partitions the given list around the picked pivot. After
            partitioning the list on the basis of the pivot element, the Quick is again applied
            recursively to two sublists i.e., the sublist to the left of the pivot element and
            the sublist to the right of the pivot element.

! ! ! use this when: Quicksort is probably more effective for datasets that fit in memory. For
                        larger data sets it proves to be inefficient so algorithms like merge
                        sort are preferred in that case.
                     Quick Sort is an in-place sort (i.e. it doesn’t require any extra storage)
                        so it is appropriate to use it for arrays.









Insertion sort works by inserting elements from an unsorted array into a sorted subsection of
the array, one item at a time.

---------

The selection sort algorithm is a comparison-based approach with a time complexity of O(N2),
making it best suited for an array data structure with a small, completely unsorted collection.

Insertion sort is an in-place comparison-based sorting algorithm that works best with partially
unsorted collections and has a time complexity of O(N2).

Merge Sort is a Divide and Conquer algorithm that divides an input collection into two portions,
recursively calls itself to sort them, and then merges the two sorted portions, with Time Complexity
O(NlogN) and Space Complexity O(N), best suited for large, unsorted collections of data.

---------

Bubble sort is an inefficient comparison-based sorting algorithm that iterates through a
collection and swaps adjacent elements, allowing the largest value to "bubble" up to the top,
with Time Complexity O(N2) and Space Complexity O(1).